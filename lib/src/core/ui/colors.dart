part of 'ui.dart';

class PColors {
  static ColorScheme get lightScheme => _lightColorScheme;
  static ColorScheme get darkScheme => _darkColorScheme;

  static const white = Color(0xffFFFFFF);
  static const offWhite = Color(0xfff7f7f7);
  static const angelicWhite = Color(0xFFF4EDE4);
  static const bhOffWhite = Color(0xfff3f0e8);
  static const bhOffWhite2 = Color(0xfff4f2ea);
  static const bhOffWhite3 = Color(0xfff5f3ed);
  static const bhOffWhite4 = Color(0xfff7f5ef);
  static const bhOffWhite5 = Color(0xfff8f6f1);
  static const bhOffWhite6 = Color(0xfff9f8f4);
  static const bhOffWhite7 = Color(0xfffaf9f6);
  static const bhOffWhite8 = Color(0xfffbfbf8);
  static const bhOffWhite9 = Color(0xfffdfcfa);

  static const dark = Color(0xff222222);
  static const dark2 = Color(0xff323232);
  static const dark3 = Color(0xff424242);
  static const dark4 = Color(0xff525252);
  static const dark5 = Color(0xff626262);
  static const dark6 = Color(0xff727272);
  static const dark7 = Color(0xff828282);
  static const dark8 = Color(0xff929292);
  static const dark9 = Color(0xffa2a2a2);
  static const offDark = ui.Color.fromARGB(255, 7, 8, 15);

  // ----------------
  // Brand Colors
  // ----------------

  static const prussianBlue = Color(0xff1c3144);
  static const prussianBlue100 = Color(0xff060a0e);
  static const prussianBlue200 = Color(0xff0b141c);
  static const prussianBlue300 = Color(0xff111e29);
  static const prussianBlue400 = Color(0xff162837);
  static const prussianBlue500 = Color(0xff1c3144);
  static const prussianBlue600 = Color(0xff345c7f);
  static const prussianBlue700 = Color(0xff4f87b7);
  static const prussianBlue800 = Color(0xff8aafcf);
  static const prussianBlue900 = Color(0xffc4d7e7);

  static const engineeringOrange = Color(0xffd00000);
  static const engineeringOrange100 = Color(0xff2a0000);
  static const engineeringOrange200 = Color(0xff540000);
  static const engineeringOrange300 = Color(0xff7d0000);
  static const engineeringOrange400 = Color(0xffa70000);
  static const engineeringOrange500 = Color(0xffd00000);
  static const engineeringOrange600 = Color(0xffff0e0e);
  static const engineeringOrange700 = Color(0xffff4a4a);
  static const engineeringOrange800 = Color(0xffff8787);
  static const engineeringOrange900 = Color(0xffffc3c3);

  static const darkOrange = Color(0xffe56b03);
  static const darkOrange100 = Color(0xff351b00);
  static const darkOrange200 = Color(0xff6a3700);
  static const darkOrange300 = Color(0xff9f5200);
  static const darkOrange400 = Color(0xffd46d00);
  static const darkOrange500 = Color(0xffff8800);
  static const darkOrange600 = Color(0xffffa31a);
  static const darkOrange700 = Color(0xffffbe33);
  static const darkOrange800 = Color(0xffffd94d);
  static const darkOrange900 = Color(0xfffff566);

  static const selectiveYellow = Color(0xffffba08);
  static const selectiveYellow100 = Color(0xff352600);
  static const selectiveYellow200 = Color(0xff6a4c00);
  static const selectiveYellow300 = Color(0xff9f7200);
  static const selectiveYellow400 = Color(0xffd49800);
  static const selectiveYellow500 = Color(0xffffba08);
  static const selectiveYellow600 = Color(0xffffc83b);
  static const selectiveYellow700 = Color(0xffffd56c);
  static const selectiveYellow800 = Color(0xffffe39d);
  static const selectiveYellow900 = Color(0xfffff1ce);

  static const cadetGray = Color(0xffa2aebb);
  static const cadetGray100 = Color(0xff1d2228);
  static const cadetGray200 = Color(0xff3a4550);
  static const cadetGray300 = Color(0xff576779);
  static const cadetGray400 = Color(0xff788a9d);
  static const cadetGray500 = Color(0xffa2aebb);
  static const cadetGray600 = Color(0xffb3bdc8);
  static const cadetGray700 = Color(0xffc6ced6);
  static const cadetGray800 = Color(0xffd9dee4);
  static const cadetGray900 = Color(0xffeceff1);

  static const steelBlue = Color(0xff3f88c5);
  static const steelBlue100 = Color(0xff0c1b28);
  static const steelBlue200 = Color(0xff183750);
  static const steelBlue300 = Color(0xff245278);
  static const steelBlue400 = Color(0xff306ea0);
  static const steelBlue500 = Color(0xff3f88c5);
  static const steelBlue600 = Color(0xff65a0d1);
  static const steelBlue700 = Color(0xff8cb8dd);
  static const steelBlue800 = Color(0xffb2d0e8);
  static const steelBlue900 = Color(0xffd9e7f4);

  // ----------------
  // Reds
  // ----------------

  static const bhRed = Color(0xfff4464c);
  static const bhRedLight = Color(0xfff5595e);
  static const bhRedLight2 = Color(0xfff66b70);
  static const bhRedLight3 = Color(0xfff77e82);
  static const bhRedLight4 = Color(0xfff89094);
  static const bhRedLight5 = Color(0xfffaa3a6);
  static const bhRedLight6 = Color(0xfffbb5b7);
  static const bhRedLight7 = Color(0xfffcc8c9);
  static const bhRedLight8 = Color(0xfffddadb);
  static const bhRedLight9 = Color(0xfffeeded);
  static const bhRedDark = Color(0xffdc3f44);
  static const bhRedDark2 = Color(0xffc3383d);
  static const bhRedDark3 = Color(0xffab3135);
  static const bhRedDark4 = Color(0xff922a2e);
  static const bhRedDark5 = Color(0xff7a2326);
  static const bhRedDark6 = Color(0xff621c1e);
  static const bhRedDark7 = Color(0xff491517);
  static const bhRedDark8 = Color(0xff310e0f);
  static const bhRedDark9 = Color(0xff180708);

  static const red = CupertinoDynamicColor.withBrightnessAndContrast(
    color: bhRed,
    darkColor: bhRedLight3,
    highContrastColor: bhRedDark,
    darkHighContrastColor: bhRedLight6,
  );

  // ----------------
  // Blues
  // ----------------

  static const bhBlue = Color(0xff0171e5);
  static const bhBlueLight = Color(0xff1a7fe8);
  static const bhBlueLight2 = Color(0xff348dea);
  static const bhBlueLight3 = Color(0xff4d9ced);
  static const bhBlueLight4 = Color(0xff67aaef);
  static const bhBlueLight5 = Color(0xff80b8f2);
  static const bhBlueLight6 = Color(0xff99c6f5);
  static const bhBlueLight7 = Color(0xffb3d4f7);
  static const bhBlueLight8 = Color(0xffcce3fa);
  static const bhBlueLight9 = Color(0xffe6f1fc);
  static const bhBlueDark = Color(0xff0166ce);
  static const bhBlueDark2 = Color(0xff015ab7);
  static const bhBlueDark3 = Color(0xff014fa0);
  static const bhBlueDark4 = Color(0xff014489);
  static const bhBlueDark5 = Color(0xff013973);
  static const bhBlueDark6 = Color(0xff002d5c);
  static const bhBlueDark7 = Color(0xff002245);
  static const bhBlueDark8 = Color(0xff00172e);
  static const bhBlueDark9 = Color(0xff000b17);

  static const blue = CupertinoDynamicColor.withBrightnessAndContrast(
    color: bhBlue,
    darkColor: bhBlueLight3,
    highContrastColor: bhBlueDark,
    darkHighContrastColor: bhBlueLight6,
  );

  // ----------------
  // Yellows
  // ----------------
  //
  // The Bauhaus Yellow's various tints and shades are pre-calculated

  static const bhYellow = Color(0xfffece3a);
  static const bhYellowLight = Color(0xfffed34e);
  static const bhYellowLight2 = Color(0xfffed861);
  static const bhYellowLight3 = Color(0xfffedd75);
  static const bhYellowLight4 = Color(0xfffee289);
  static const bhYellowLight5 = Color(0xffffe79d);
  static const bhYellowLight6 = Color(0xffffebb0);
  static const bhYellowLight7 = Color(0xfffff0c4);
  static const bhYellowLight8 = Color(0xfffff5d8);
  static const bhYellowLight9 = Color(0xfffffaeb);
  static const bhYellowDark = Color(0xffe5b934);
  static const bhYellowDark2 = Color(0xffcba52e);
  static const bhYellowDark3 = Color(0xffb29029);
  static const bhYellowDark4 = Color(0xff987c23);
  static const bhYellowDark5 = Color(0xff7f671d);
  static const bhYellowDark6 = Color(0xff665217);
  static const bhYellowDark7 = Color(0xff4c3e11);
  static const bhYellowDark8 = Color(0xff33290c);
  static const bhYellowDark9 = Color(0xff191506);

  static const yellow = CupertinoDynamicColor.withBrightnessAndContrast(
    color: bhYellow,
    darkColor: bhYellowLight3,
    highContrastColor: bhYellowDark,
    darkHighContrastColor: bhYellowLight6,
  );

  // ----------------
  // Other Bauhaus Colors
  // ----------------

  static const basicColors = [
    bhRed,
    bhBlue,
    bhYellow,
    bhOrange,
  ];

  static const bhOrange = Color(0xffe58d03);
  static const bhOrangeLight3 = Color(0xffedaf4f);
  static const bhOrangeLight6 = Color(0xfff5d19a);
  static const bhOrangeDark = Color(0xffce7f03);
  static const orange = CupertinoDynamicColor.withBrightnessAndContrast(
    color: bhOrange,
    darkColor: bhOrangeLight3,
    highContrastColor: bhOrangeDark,
    darkHighContrastColor: bhOrangeLight6,
  );

  static const bhCyan = Color(0xff84aeaa);
  static const bhCyanLight3 = Color(0xffa9c6c4);
  static const bhCyanLight6 = Color(0xffcedfdd);
  static const bhCyanDark = Color(0xff779d99);
  static const cyan = CupertinoDynamicColor.withBrightnessAndContrast(
    color: bhCyan,
    darkColor: bhCyanLight3,
    highContrastColor: bhCyanDark,
    darkHighContrastColor: bhCyanLight6,
  );

  // ----------------
  // Pastel Colors
  // ----------------

  static const blush = Color(0xffF2EAE4);
  static const pastelPink = Color(0xfff29bbb);
  static const violet = Color(0xffA6729D);
  static const pastelRed = Color(0xffF25E6C);
  static const pastelOrange = Color(0xffFF8557);
  static const pastelYellow = Color(0xffF8D558);
  static const neonGreen = Color(0xff35E895);
  static const matteBlue = Color(0xff6CBAD9);
  static const blueGray = Color(0xff676789);
  static const brown = Color(0xffE5C9A0);

  static const pastelColors = [
    blush,
    pastelPink,
    violet,
    pastelRed,
    pastelOrange,
    pastelYellow,
    neonGreen,
    matteBlue,
    blueGray,
    brown,
  ];

  // ----------------
  // Grays
  // ----------------

  static const _grayLightModeNoOpacity = Color(0xFFE0E0E0);
  static final _grayDarkModeNoOpacity = Colors.grey.shade(.95);
  static final _grayLightMode = Colors.black.withOpacity(0.05);
  static final _grayLightModeHighContrast = Colors.black.withOpacity(0.085);
  static const _grayDarkMode = Colors.white10;
  static final _grayDarkModeHighContrast = Colors.white.withOpacity(0.15);

  static final _lightGrayLightMode = Colors.black.withOpacity(0.025);
  static final _lightGrayLightModeHighContrast =
      Colors.black.withOpacity(0.035);
  static final _lightGrayDarkMode = Colors.white.withOpacity(0.08);
  static final _lightGrayDarkModeHighContrast = Colors.white.withOpacity(0.12);

  static const _darkGrayLightMode = Colors.black26;
  static const _darkGrayLightModeHighContrast = Colors.black38;
  static const _darkGrayDarkMode = Colors.white30;
  static final _darkGrayDarkModeHighContrast = Colors.white.withOpacity(0.45);

  static const _textGrayLightMode = Colors.black54;
  static final _textGrayLightModeHighContrast = Colors.black.withOpacity(0.64);
  static const _textGrayDarkMode = Colors.white54;
  static final _textGrayDarkModeHighContrast = Colors.white.withOpacity(0.75);

  static final lightGray = CupertinoDynamicColor.withBrightnessAndContrast(
    color: _lightGrayLightMode,
    darkColor: _lightGrayDarkMode,
    highContrastColor: _lightGrayLightModeHighContrast,
    darkHighContrastColor: _lightGrayDarkModeHighContrast,
  );
  static final opaqueLightGray =
      CupertinoDynamicColor.withBrightnessAndContrast(
    color: Colors.grey.tint(.95),
    darkColor: Colors.grey.shade(.9),
    highContrastColor: Colors.grey.tint(.9),
    darkHighContrastColor: Colors.grey.shade(.7),
  );
  static final gray = CupertinoDynamicColor.withBrightnessAndContrast(
    color: _grayLightMode,
    darkColor: _grayDarkMode,
    highContrastColor: _grayLightModeHighContrast,
    darkHighContrastColor: _grayDarkModeHighContrast,
  );
  static final darkGray = CupertinoDynamicColor.withBrightnessAndContrast(
    color: _darkGrayLightMode,
    darkColor: _darkGrayDarkMode,
    highContrastColor: _darkGrayLightModeHighContrast,
    darkHighContrastColor: _darkGrayDarkModeHighContrast,
  );
  static final textGray = CupertinoDynamicColor.withBrightnessAndContrast(
    color: _textGrayLightMode,
    darkColor: _textGrayDarkMode,
    highContrastColor: _textGrayLightModeHighContrast,
    darkHighContrastColor: _textGrayDarkModeHighContrast,
  );

  static Color pastel([Color base = matteBlue]) {
    // make colors more pastel
    final hsl = HSLColor.fromColor(base);
    return hsl.withLightness(0.9).toColor();
  }

  static String defaultBlurhash(
    BuildContext context, [
    ThemeMode mode = ThemeMode.system,
  ]) {
    const lightBlurhash = r'LZR_|%,k*IEn-BNNOs$wuOXTVFsl';
    const darkBlurhash = r'LSG*4,}%1FALrDNhFds50zEO+~nh';

    return Theme.of(context).resolveBrightness(
      lightBlurhash,
      darkBlurhash,
      mode,
    );
  }

  // ----------------
  // Dim Colors
  // ----------------

  static const loveAffair = Color(0xFFFFBEC8);
  static const daintyPeach = Color(0xFFFFCDB9);
  static const vanilla = Color(0xFFF3E5AB);
  static const frozenForest = Color(0xFFC9E3BC);
  static const opal = Color(0xFFAEE0E4);
  static const foggyLove = Color(0xFFD5C7E8);

  // ----------------
  // Bright Colors
  // ----------------

  static const rockNRose = Color(0xFFFC8AAA);
  static const atomicTangerine = Color(0xFFFF9966);
  static const endlessSummer = Color(0xFFF7CF00);
  static const freshGreen = Color(0xFF69D84F);
  static const picnicDaySky = Color(0xFF00CCEE);
  static const lilac = Color(0xFFCEA2FD);

  // ----------------
  // Useful combination of Dim and Bright Colors
  // ----------------

  static const rosePink = CupertinoDynamicColor.withBrightness(
    color: rockNRose,
    darkColor: loveAffair,
  );
  static const peachOrange = CupertinoDynamicColor.withBrightness(
    color: atomicTangerine,
    darkColor: daintyPeach,
  );
  static const banana = CupertinoDynamicColor.withBrightness(
    color: endlessSummer,
    darkColor: vanilla,
  );
  static const mintGreen = CupertinoDynamicColor.withBrightness(
    color: freshGreen,
    darkColor: frozenForest,
  );
  static const skyBlue = CupertinoDynamicColor.withBrightness(
    color: picnicDaySky,
    darkColor: opal,
  );
  static const lilacPurple = CupertinoDynamicColor.withBrightness(
    color: lilac,
    darkColor: foggyLove,
  );
  static const adaptiveColors = [
    rosePink,
    peachOrange,
    banana,
    mintGreen,
    skyBlue,
    lilacPurple,
  ];

  /// Returns the selection colors for the current context and theme mode.
  ///
  /// The first color is the background color, and the second color is the
  /// foreground color.
  ///
  static (Color, Color) selectionColors(
    BuildContext context, [
    ThemeMode mode = ThemeMode.system,
  ]) {
    final theme = Theme.of(context);
    return (
      theme.resolveColor(PColors.matteBlue, PColors.bhBlueLight9, mode: mode),
      theme.resolveColor(Colors.white, PColors.offDark, mode: mode),
    );
  }
}

extension ColorUtilsExtension on Color {
  Color get pastel => ColorUtils.getPastelColorFromString(toString());
  Color get inverse => ColorUtils.getInverseColor(this);
  String toHexStringRGB() {
    final r = red.toRadixString(16).padLeft(2, '0');
    final g = green.toRadixString(16).padLeft(2, '0');
    final b = blue.toRadixString(16).padLeft(2, '0');
    return '#$r$g$b';
  }

  Color adaptForDarkMode() {
    final hsl = HSLColor.fromColor(this);
    final lightness = hsl.lightness;
    final saturation = hsl.saturation;
    final hue = hsl.hue;

    if (lightness <= 0.75) {
      return HSLColor.fromAHSL(
        1.0,
        hue,
        saturation,
        0.75,
      ).toColor();
    }

    return this;
  }

  Color adaptForLightMode() {
    final hsl = HSLColor.fromColor(this);
    final lightness = hsl.lightness;
    final saturation = hsl.saturation;
    final hue = hsl.hue;

    if (lightness > 0.4) {
      return HSLColor.fromAHSL(
        1.0,
        hue,
        saturation,
        0.4,
      ).toColor();
    }

    return this;
  }

  Color adaptForContext(BuildContext context) {
    final brightness = Theme.of(context).brightness;
    switch (brightness) {
      case Brightness.light:
        return adaptForLightMode();
      case Brightness.dark:
        return adaptForDarkMode();
    }
  }

  Color inverseAdaptForContext(BuildContext context) {
    final brightness = Theme.of(context).brightness;
    switch (brightness) {
      case Brightness.light:
        return adaptForDarkMode();
      case Brightness.dark:
        return adaptForLightMode();
    }
  }

  CupertinoDynamicColor adaptive() => CupertinoDynamicColor.withBrightness(
        color: adaptForLightMode(),
        darkColor: adaptForDarkMode(),
      );

  CupertinoDynamicColor inverseAdaptive() =>
      CupertinoDynamicColor.withBrightness(
        color: adaptForDarkMode(),
        darkColor: adaptForLightMode(),
      );

  Color withOpacityFactor(double factor) {
    return Color.fromARGB(
      ((alpha / 255) * factor * 255).round().clamp(0, 255),
      red,
      green,
      blue,
    );
  }
}

typedef ProminentColors = ({
  Color light,
  Color dark,
});

class ColorUtils {
  static Color colorFromHexString(String hexString) {
    final hex = hexString.replaceFirst('#', '');
    final r = int.parse(hex.substring(0, 2), radix: 16);
    final g = int.parse(hex.substring(2, 4), radix: 16);
    final b = int.parse(hex.substring(4, 6), radix: 16);
    return Color.fromARGB(255, r, g, b);
  }

  static Color getPastelColorFromString(String string) {
    final random = Random(string.hashCode);
    final hue = random.nextDouble() * 360;
    const saturation = 0.9;
    const lightness = 0.45;
    return HSLColor.fromAHSL(
      1.0,
      hue,
      saturation,
      lightness,
    ).toColor();
  }

  static Color getBrightColorFromString(String string) {
    final random = Random(string.hashCode);
    final hue = random.nextDouble() * 360;
    const saturation = 0.9;
    const lightness = 0.7;
    return HSLColor.fromAHSL(
      1.0,
      hue,
      saturation,
      lightness,
    ).toColor();
  }

  static Color getInverseColor(Color color) {
    final r = 255 - color.red;
    final g = 255 - color.green;
    final b = 255 - color.blue;

    return Color.fromARGB(
      (color.opacity * 255).round(),
      r,
      g,
      b,
    );
  }

  static Future<List<Color>> detectImageColors(
    ImageProvider image, [
    int maximumColorCount = 6,
  ]) async {
    try {
      final paletteGenerator = await PaletteGenerator.fromImageProvider(
        image,
        maximumColorCount: maximumColorCount,
        timeout: const Duration(seconds: 5),
      );
      return paletteGenerator.colors.toList();
    } on TimeoutException {
      return [];
    }
  }

  static Future<ProminentColors> getVibrantColors(
    ImageProvider imageProvider,
    String cacheKey, [
    ProminentColors? fallbackColors,
  ]) async {
    try {
      final ImageStream stream = imageProvider.resolve(
        const ImageConfiguration(
          size: Size(200.0, 200.0),
          devicePixelRatio: 1.0,
        ),
      );
      final imageCompleter = Completer<ui.Image>();
      Timer? loadFailureTimeout;
      late ImageStreamListener listener;
      listener = ImageStreamListener((ImageInfo info, bool synchronousCall) {
        loadFailureTimeout?.cancel();
        stream.removeListener(listener);
        imageCompleter.complete(info.image);
      });
      loadFailureTimeout = Timer(const Duration(seconds: 5), () {
        stream.removeListener(listener);
        imageCompleter.completeError(
          TimeoutException(
            'Timeout occurred trying to load from $imageProvider',
          ),
        );
      });
      stream.addListener(listener);
      final image = await imageCompleter.future;
      final imageData = await image.toByteData();
      if (imageData == null) {
        throw StateError('Failed to encode the image.');
      }
      final paletteGenerator = await compute(
        _generatePalette,
        (imageData, image.width, image.height),
      );

      final muted = paletteGenerator.mutedColor?.color;
      final lightMuted = paletteGenerator.lightMutedColor?.color;
      final darkMuted = paletteGenerator.darkMutedColor?.color;
      final vibrant = paletteGenerator.vibrantColor?.color;
      final lightVibrant = paletteGenerator.lightVibrantColor?.color;
      final darkVibrant = paletteGenerator.darkVibrantColor?.color;

      final light = darkMuted ??
          lightMuted ??
          fallbackColors?.light ??
          Colors.transparent;

      final dark = lightVibrant ??
          vibrant ??
          darkVibrant ??
          muted ??
          fallbackColors?.dark ??
          Colors.transparent;

      return (light: light, dark: dark);
    } on TimeoutException {
      return (light: Colors.transparent, dark: Colors.transparent);
    }
  }
}

Future<PaletteGenerator> _generatePalette(
  (ByteData data, int width, int height) m,
) {
  return PaletteGenerator.fromByteData(
    EncodedImage(m.$1, width: m.$2, height: m.$3),
    maximumColorCount: 6,
  );
}

extension ThemeModeDependence on CupertinoDynamicColor {
  Color reverseResolveFrom(BuildContext context) {
    return reverseResolveWithTheme(
      Theme.of(context),
      isHighContrast: MediaQuery.maybeHighContrastOf(context) ?? false,
    );
  }

  Color resolveFromMode(BuildContext context, ThemeMode mode) {
    final theme = Theme.of(context);
    final isLight = theme.brightness == Brightness.light;
    final highContrast = MediaQuery.maybeHighContrastOf(context) ?? false;
    switch ((mode, isLight)) {
      case (ThemeMode.light, false) || (ThemeMode.dark, true):
        return reverseResolveWithTheme(theme, isHighContrast: highContrast);
      case (ThemeMode.dark, false) || (ThemeMode.light, true):
      case (ThemeMode.system, _):
        return resolveWithTheme(theme, isHighContrast: highContrast);
    }
  }

  Color resolveWithTheme(ThemeData theme, {bool isHighContrast = false}) {
    final lerpValue = theme.interpolationValue;
    return isHighContrast
        ? Color.lerp(highContrastColor, darkHighContrastColor, lerpValue)!
        : Color.lerp(color, darkColor, lerpValue)!;
  }

  Color reverseResolveWithTheme(
    ThemeData theme, {
    bool isHighContrast = false,
  }) {
    final modifiedTheme = theme.copyWith(
      brightness: theme.brightness == Brightness.light
          ? Brightness.dark
          : Brightness.light,
    );
    return resolveWithTheme(modifiedTheme, isHighContrast: isHighContrast);
  }
}

extension MoreColors on ThemeData {
  Color resolveColor(
    Color light,
    Color dark, {
    bool inverse = false,
    bool isHighContrast = false,
    ThemeMode mode = ThemeMode.system,
  }) {
    switch (mode) {
      case ThemeMode.light:
        return inverse ? dark : light;
      case ThemeMode.dark:
        return inverse ? light : dark;
      case ThemeMode.system:
        final dynamicColor =
            CupertinoDynamicColor.withBrightness(color: light, darkColor: dark);
        return inverse
            ? dynamicColor.reverseResolveWithTheme(
                this,
                isHighContrast: isHighContrast,
              )
            : dynamicColor.resolveWithTheme(
                this,
                isHighContrast: isHighContrast,
              );
    }
  }

  Color get lightGray =>
      resolveColor(PColors._lightGrayLightMode, PColors._lightGrayDarkMode);

  Color get gray => resolveColor(
        PColors._grayLightMode,
        PColors._grayDarkMode,
      );

  Color get grayNoOpacity => resolveColor(
        PColors._grayLightModeNoOpacity,
        PColors._grayDarkModeNoOpacity,
      );

  Color get darkGray => resolveColor(
        PColors._darkGrayLightMode,
        PColors._darkGrayDarkMode,
      );

  Color get textGray => resolveColor(
        Colors.black54,
        Colors.white54,
      );

  Color get offWhite => resolveColor(
        PColors.offWhite,
        PColors.bhOffWhite,
      );

  Color get inverseOffWhite => resolveColor(
        PColors.bhOffWhite,
        PColors.offWhite,
      );

  Color get offColor => resolveColor(
        PColors.offWhite,
        PColors.offDark,
      );

  Color get inverseOffColor => resolveColor(
        PColors.offDark,
        PColors.offWhite,
      );

  Color get dark => resolveColor(
        PColors.dark,
        PColors.offWhite,
      );

  Color get success => resolveColor(
        CupertinoColors.activeGreen.color,
        CupertinoColors.activeGreen.darkColor,
      );

  Color get inverseLightGray => resolveColor(
        Colors.black.withOpacity(0.025),
        Colors.white.withOpacity(0.08),
        inverse: true,
      );

  Color get inverseGray => resolveColor(
        PColors._grayLightMode,
        PColors._grayDarkMode,
        inverse: true,
      );

  Color get inverseDarkGray => resolveColor(
        Colors.black26,
        Colors.white30,
        inverse: true,
      );

  Color get inverseTextGray => resolveColor(
        Colors.black54,
        Colors.white54,
        inverse: true,
      );

  Color get neutral => resolveColor(
        Colors.white,
        Colors.black,
      );

  Color get inverseNeutral => resolveColor(
        Colors.black,
        Colors.white,
      );

  Color get blue => PColors.blue.resolveWithTheme(this);

  Color get yellow => PColors.yellow.resolveWithTheme(this);

  Color get orange => resolveColor(
        CupertinoColors.systemOrange.color,
        CupertinoColors.systemOrange.darkColor,
      );
}

extension SpecificTintsShades on Color {
  /// Internal method to convert the Color to a list of RGB values.
  List<int> _toRgb() {
    return [red, green, blue];
  }

  /// Internal method to create a Color from RGB values.
  static Color _fromRgb(int r, int g, int b, [double opacity = 1.0]) {
    return Color.fromRGBO(r, g, b, opacity);
  }

  /// Internal method to create a tint of the Color.
  Color tint(double factor) {
    assert(factor >= 0 && factor <= 1, 'Factor must be between 0 and 1');

    final List<int> rgb = _toRgb();
    final List<int> tintedRgb = rgb.map((c) {
      return (c + ((255 - c) * factor)).round();
    }).toList();

    return _fromRgb(tintedRgb[0], tintedRgb[1], tintedRgb[2], opacity);
  }

  /// Internal method to create a shade of the Color.
  Color shade(double factor) {
    assert(factor >= 0 && factor <= 1, 'Factor must be between 0 and 1');

    final List<int> rgb = _toRgb();
    final List<int> shadedRgb = rgb.map((c) {
      return (c * (1.0 - factor)).round();
    }).toList();

    return _fromRgb(shadedRgb[0], shadedRgb[1], shadedRgb[2], opacity);
  }

  // Tint methods
  Color get tint10 => tint(0.1);
  Color get tint20 => tint(0.2);
  Color get tint30 => tint(0.3);
  Color get tint40 => tint(0.4);
  Color get tint50 => tint(0.5);
  Color get tint60 => tint(0.6);
  Color get tint70 => tint(0.7);
  Color get tint80 => tint(0.8);
  Color get tint90 => tint(0.9);

  // Shade methods
  Color get shade10 => shade(0.1);
  Color get shade20 => shade(0.2);
  Color get shade30 => shade(0.3);
  Color get shade40 => shade(0.4);
  Color get shade50 => shade(0.5);
  Color get shade60 => shade(0.6);
  Color get shade70 => shade(0.7);
  Color get shade80 => shade(0.8);
  Color get shade90 => shade(0.9);
}
